<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinetic Matrix Sculpture & The Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #e8e8e8; /* 极简灰白背景 */
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .instruction {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #999;
            font-size: 10px;
            letter-spacing: 1px;
            pointer-events: none;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <div id="loading">GENERATING VOXEL ECOSYSTEM...</div>
    <div class="instruction">Interactive Surface // Digital Nature</div>

    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * 30-Year Veteran Frontend Engineer Implementation
         * Update: 
         * 1. Pruned "Front" Foliage to reveal trunk structure.
         * 2. View-dependent density optimization.
         */

        // --- 配置参数 (Tweakable Parameters) ---
        const CONFIG = {
            // Ground Matrix
            gridSize: 50,
            unitSize: 0.8,
            gap: 0.2,
            pillarHeight: 60,
            maxElevation: 12,
            influenceRadius: 6,
            decaySpeed: 6.0,
            lerpFactor: 0.1,
            color: 0xffffff,
            bgColor: 0xe0e0e0,

            // Tree Settings
            treeHeight: 22,      // 树高
            growthSpeed: 0.5,
            
            // Colors
            trunkColor: 0x5D4037,   // 坚实的深褐色 (Wood)
            foliageColor: 0x2E7D32, // 自然的深绿色 (Forest Green)
            
            // Morphology
            trunkRadius: 2.2,       // 树干粗细
            branchSpread: 1.4       // 树冠横向扩散系数
        };

        // --- 全局变量 ---
        let scene, camera, renderer;
        let groundMesh, trunkMesh, foliageMesh; // 分离地面、树干、树叶
        let dummy = new THREE.Object3D();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(-1000, -1000);
        
        // 地面数据
        let targetY = [];
        let currentY = [];
        let gridCols, gridRows;

        // 树木数据 (分为两组)
        let trunkInstances = []; 
        let foliageInstances = [];
        let treeGrowthProgress = 0;

        init();
        animate();

        function init() {
            const container = document.body;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bgColor);
            scene.fog = new THREE.Fog(CONFIG.bgColor, 40, 90);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(30, 45, 30);
            camera.lookAt(0, 10, 0); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); 
            dirLight.position.set(50, 80, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 200;
            const d = 50;
            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            scene.add(dirLight);
            
            const fillLight = new THREE.DirectionalLight(0xb4c6d6, 0.3);
            fillLight.position.set(-20, 10, -20);
            scene.add(fillLight);

            // 生成地面矩阵
            createMatrix();

            // 生成参天大树
            createVoxelTree();

            // 交互平面
            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
            window.raycastPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            window.raycastPlane.rotation.x = -Math.PI / 2;
            scene.add(window.raycastPlane);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
            }, 1000);
        }

        // --- 1. 地面生成逻辑 ---
        function createMatrix() {
            const totalSize = CONFIG.gridSize;
            const step = CONFIG.unitSize + CONFIG.gap;
            gridCols = Math.floor(totalSize * 2);
            gridRows = Math.floor(totalSize * 2);
            const totalInstances = gridCols * gridRows;

            const geometry = new THREE.BoxGeometry(CONFIG.unitSize, CONFIG.pillarHeight, CONFIG.unitSize);
            geometry.translate(0, -CONFIG.pillarHeight / 2, 0); 

            const material = new THREE.MeshPhysicalMaterial({
                color: CONFIG.color,
                roughness: 0.8,
                metalness: 0.1
            });

            groundMesh = new THREE.InstancedMesh(geometry, material, totalInstances);
            groundMesh.castShadow = true;
            groundMesh.receiveShadow = true;
            groundMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            let i = 0;
            const offset = (gridCols * step) / 2;

            for (let x = 0; x < gridCols; x++) {
                for (let z = 0; z < gridRows; z++) {
                    const worldX = x * step - offset;
                    const worldZ = z * step - offset;
                    const distFromCenter = Math.sqrt(worldX*worldX + worldZ*worldZ);
                    
                    // 树根半径
                    if (distFromCenter < 3.8) {
                        dummy.position.set(10000, 0, 10000);
                    } else {
                        dummy.position.set(worldX, 0, worldZ);
                    }

                    dummy.updateMatrix();
                    groundMesh.setMatrixAt(i, dummy.matrix);
                    targetY[i] = 0;
                    currentY[i] = 0;
                    i++;
                }
            }
            scene.add(groundMesh);
        }

        // --- 2. 树木生成逻辑 (Refined Culling) ---
        function createVoxelTree() {
            const trunkVoxels = [];
            const foliageVoxels = [];
            const step = CONFIG.unitSize + CONFIG.gap;

            // Helper set to avoid overlapping voxels within the same type
            const occupied = new Set();
            
            function addVoxel(vx, vy, vz, type) {
                const x = Math.round(vx / step) * step;
                const y = Math.round(vy / step) * step;
                const z = Math.round(vz / step) * step;
                
                const key = `${x},${y},${z}`;
                if (occupied.has(key)) return;
                if (y < 0) return;

                occupied.add(key);
                
                if (type === 'trunk') trunkVoxels.push({x, y, z});
                else foliageVoxels.push({x, y, z});
            }

            // A. 生成树干 (Trunk) - 棕色
            const trunkHeight = CONFIG.treeHeight * 0.95; 
            const trunkRadius = CONFIG.trunkRadius;
            
            for (let y = 0; y < trunkHeight; y += step) {
                const progress = y / trunkHeight;
                // 树干曲线
                const currentR = trunkRadius * (1 - progress * 0.4) + (progress > 0.8 ? (progress - 0.8) * 3 : 0);
                
                for (let x = -4; x <= 4; x += step) {
                    for (let z = -4; z <= 4; z += step) {
                        if (x*x + z*z < currentR*currentR) {
                            if (Math.random() > 0.15) addVoxel(x, y, z, 'trunk');
                        }
                    }
                }
            }

            // B. 生成树冠 (Foliage) - 绿色
            const spread = CONFIG.branchSpread;
            const h = CONFIG.treeHeight;
            
            // 定义树冠球体簇 (Clusters)
            // 调整：前方的 Cluster (x>0, z>0) 被抬高或移除
            const clusters = [
                // 顶部主冠
                {x: 0, y: h * 1.05, z: 0, r: 9}, 
                
                // 侧面第一层 (Modified)
                // "前方" Cluster (Side 1) 原本是 (6, 0.95h, 6)，现在抬高并缩小
                {x: 6 * spread, y: h * 1.15, z: 6 * spread, r: 5}, 
                
                {x: -6 * spread, y: h * 1.0, z: 5 * spread, r: 6},
                {x: 5 * spread, y: h * 0.9, z: -6 * spread, r: 7},
                {x: -5 * spread, y: h * 1.05, z: -5 * spread, r: 6},
                
                // 侧面第二层 (Lower layers)
                {x: 9 * spread, y: h * 0.85, z: 0, r: 5},
                {x: -9 * spread, y: h * 0.9, z: 0, r: 5},
                
                // 右前方 (x=0, z=9) 原本较低，现在也稍作处理
                {x: 0, y: h * 0.95, z: 9 * spread, r: 5}, 
                
                {x: 0, y: h * 0.9, z: -9 * spread, r: 5},
            ];

            clusters.forEach(cluster => {
                const rSq = cluster.r * cluster.r;
                for (let x = -cluster.r; x <= cluster.r; x += step) {
                    for (let y = -cluster.r; y <= cluster.r; y += step) {
                        for (let z = -cluster.r; z <= cluster.r; z += step) {
                            
                            const distSq = x*x + (y*1.2)*(y*1.2) + z*z; 
                            
                            if (distSq < rSq) {
                                // 边缘疏松
                                if (Math.random() > (distSq / rSq) * 0.4) {
                                    
                                    // --- 关键修改：前方视线剔除 ---
                                    const worldX = cluster.x + x;
                                    const worldZ = cluster.z + z;
                                    const worldY = cluster.y + y;
                                    
                                    // 摄像机在 (30, 45, 30), 看向原点
                                    // 所以 x > 0 && z > 0 的区域是"前方"
                                    // 我们过滤掉这里的低处树叶
                                    if (worldX > 2 && worldZ > 2 && worldY < h * 0.95) {
                                        // 90% 概率剔除前方的低处遮挡物，保留一点点以防穿帮
                                        if (Math.random() > 0.1) continue; 
                                    }

                                    addVoxel(worldX, worldY, worldZ, 'foliage');
                                }
                            }
                        }
                    }
                }
            });

            // C. 创建 Mesh
            const boxGeo = new THREE.BoxGeometry(CONFIG.unitSize, CONFIG.unitSize, CONFIG.unitSize);

            // 1. Trunk
            const trunkMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.trunkColor,
                roughness: 0.9,
                metalness: 0.0
            });
            trunkMesh = new THREE.InstancedMesh(boxGeo, trunkMat, trunkVoxels.length);
            setupMesh(trunkMesh, trunkVoxels, trunkInstances);
            scene.add(trunkMesh);

            // 2. Foliage
            const foliageMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.foliageColor,
                roughness: 0.8,
                metalness: 0.0,
                clearcoat: 0.0
            });
            foliageMesh = new THREE.InstancedMesh(boxGeo, foliageMat, foliageVoxels.length);
            setupMesh(foliageMesh, foliageVoxels, foliageInstances);
            scene.add(foliageMesh);
        }

        // Helper to setup instanced mesh
        function setupMesh(mesh, sourceVoxels, targetInstances) {
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            sourceVoxels.forEach((v, i) => {
                dummy.position.set(v.x, v.y, v.z);
                dummy.scale.set(0, 0, 0);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                
                targetInstances.push({
                    id: i,
                    x: v.x, y: v.y, z: v.z,
                    currentScale: 0
                });
            });
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- A. 地面矩阵逻辑 (保持原样) ---
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(window.raycastPlane);
            let intersectPoint = null;
            if (intersects.length > 0) intersectPoint = intersects[0].point;

            let i = 0;
            let needsGroundUpdate = false;
            const step = CONFIG.unitSize + CONFIG.gap;
            const offset = (gridCols * step) / 2;
            const count = groundMesh.count;

            for (let idx = 0; idx < count; idx++) {
                const col = Math.floor(idx / gridRows);
                const row = idx % gridRows;
                const posX = col * step - offset;
                const posZ = row * step - offset;

                if (Math.abs(posX) < 3.8 && Math.abs(posZ) < 3.8) continue;

                let target = 0;
                if (intersectPoint) {
                    const dx = posX - intersectPoint.x;
                    const dz = posZ - intersectPoint.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < CONFIG.influenceRadius) {
                        const normalizedDist = dist / CONFIG.influenceRadius;
                        target = Math.exp(-normalizedDist * CONFIG.decaySpeed) * CONFIG.maxElevation;
                    }
                }

                if (Math.abs(currentY[idx] - target) > 0.001) {
                    currentY[idx] += (target - currentY[idx]) * CONFIG.lerpFactor;
                    dummy.position.set(posX, currentY[idx], posZ);
                    dummy.updateMatrix();
                    groundMesh.setMatrixAt(idx, dummy.matrix);
                    needsGroundUpdate = true;
                }
            }
            if (needsGroundUpdate) groundMesh.instanceMatrix.needsUpdate = true;


            // --- B. 树木生长逻辑 ---
            if (treeGrowthProgress < CONFIG.treeHeight + 10) {
                treeGrowthProgress += CONFIG.growthSpeed;
                
                // Animate Trunk
                animateTreePart(trunkMesh, trunkInstances);
                // Animate Foliage
                animateTreePart(foliageMesh, foliageInstances);
            }

            renderer.render(scene, camera);
        }

        function animateTreePart(mesh, instances) {
            let needsUpdate = false;
            instances.forEach(node => {
                const heightOffset = (mesh === foliageMesh) ? 2 : 0;
                const triggerHeight = node.y + Math.sin(node.x * 0.5) * 2 + heightOffset;
                
                let targetScale = 0;
                if (treeGrowthProgress > triggerHeight) {
                    const age = treeGrowthProgress - triggerHeight;
                    targetScale = Math.min(1, age * 0.4); 
                    if (targetScale > 0.8 && targetScale < 1) {
                         targetScale = 1.1 - (1 - targetScale); 
                    }
                    if (age > 2.5) targetScale = 1; 
                }

                if (Math.abs(node.currentScale - targetScale) > 0.01) {
                    node.currentScale += (targetScale - node.currentScale) * 0.1;
                    
                    dummy.position.set(node.x, node.y, node.z);
                    dummy.scale.set(node.currentScale, node.currentScale, node.currentScale);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(node.id, dummy.matrix);
                    needsUpdate = true;
                }
            });
            if (needsUpdate) mesh.instanceMatrix.needsUpdate = true;
        }
    </script>
</body>
</html>